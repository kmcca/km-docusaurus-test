"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[68121],{63403:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>r,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>c,toc:()=>l});var n=a(85893),i=a(11151);const s={title:"Matching flaws between scans of the same application",slug:"/r/c_review_matchflaws"},o=void 0,c={id:"guides/findings/improve/matching_flaws_between_scans",title:"Matching flaws between scans of the same application",description:"Carrying mitigations and comments forward from one scan to the next requires that the flaws match from one scan to the next of the same application.",source:"@site/docs/guides/09_findings/06_improve/08_matching_flaws_between_scans.md",sourceDirName:"guides/09_findings/06_improve",slug:"/r/c_review_matchflaws",permalink:"/km-docusaurus-test/r/c_review_matchflaws",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:8,frontMatter:{title:"Matching flaws between scans of the same application",slug:"/r/c_review_matchflaws"},sidebar:"tutorialSidebar",previous:{title:"Generate link to latest instance of a flaw",permalink:"/km-docusaurus-test/r/t_share_flaw_link"},next:{title:"Working collaboratively in Triage Flaws",permalink:"/km-docusaurus-test/r/review_collaboration"}},r={},l=[{value:"Static Analysis flaw matching",id:"static-analysis-flaw-matching",level:2},{value:"Known limitations",id:"known-limitations",level:3},{value:"Duplications",id:"duplications",level:4},{value:"Third-party fingerprinting",id:"third-party-fingerprinting",level:4},{value:"Dynamic Analysis flaw matching",id:"dynamic-analysis-flaw-matching",level:2}];function h(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"Carrying mitigations and comments forward from one scan to the next requires that the flaws match from one scan to the next of the same application."}),"\n",(0,n.jsx)(t.p,{children:"The flaw-matching process occurs when you perform two scans of the same application. To identify flaws that might be identical between the two scans, Veracode compares the results of the second scan to the first scan. If Veracode finds a match for any given flaw, it forwards any comments or mitigation information you supplied for the original flaw."}),"\n",(0,n.jsx)(t.h2,{id:"static-analysis-flaw-matching",children:"Static Analysis flaw matching"}),"\n",(0,n.jsx)(t.p,{children:"When publishing new static analysis scan results, Veracode searches these locations within the application to determine if a potentially matching flaw exists:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"All Static Analysis policy scans"}),"\n",(0,n.jsx)(t.li,{children:"All Static Analysis sandbox scans"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"Veracode uses a complete model of the application program logic and data flow to identify the location of a flaw. Small changes in code location, including changes in line numbers, do not affect how Veracode identifies flaws. You can still change the code containing a flaw so that it no longer matches to a flaw that Veracode found previously."}),"\n",(0,n.jsx)(t.p,{children:"For a flaw to match across scans, it must meet these criteria:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"The source file name has not changed."}),"\n",(0,n.jsxs)(t.li,{children:["The name of the module in which the flaw is located cannot change between scans. However, Veracode can match flaws if the end of the module name contains a varying numeric sequence. For example, ",(0,n.jsx)(t.code,{children:"foo-123.jar"})," matches with ",(0,n.jsx)(t.code,{children:"foo-125.jar"}),"."]}),"\n"]}),"\n",(0,n.jsxs)(t.p,{children:["Veracode Static Analysis requires debug information to find flaw locations for some languages, including .NET and Java. If an application is compiled without debug information, flaw matching may be impaired. For the list of languages that require compilation with debug information, see the ",(0,n.jsx)(t.a,{href:"/km-docusaurus-test/r/compilation_packaging",children:"Veracode packaging requirements"}),"."]}),"\n",(0,n.jsx)(t.p,{children:"This table lists some known scenarios in which flaw matching does not occur. If a flaw is tagged as mitigated in a given scan, but the same flaw appears in a later scan with a different ID and not mitigated, it is likely because of one of these scenarios:"}),"\n",(0,n.jsxs)(t.table,{children:[(0,n.jsx)(t.thead,{children:(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.th,{children:"Cause of problem"}),(0,n.jsx)(t.th,{children:"Explanation"})]})}),(0,n.jsxs)(t.tbody,{children:[(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Different module names"}),(0,n.jsx)(t.td,{children:"When identifying if a flaw is the same as a previously mitigated flaw, Veracode uses the module name to ensure that the analysis matches flaws that are in the same context. Veracode matches modules with different version numbers, as described above, but there are styles of versioning that can cause this matching to fail."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"High flaw density"}),(0,n.jsx)(t.td,{children:"Veracode sometimes cannot determine which flaws in the new scan map to flaws in the old scan. For example, one scan of an application has five flaws of a specific type in a function, and the next scan has four flaws of that same type in that same function."})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Moved source files"}),(0,n.jsxs)(t.td,{children:["Veracode tries to detect source files that have moved within the source tree. For example, ",(0,n.jsx)(t.code,{children:"com/veracode/Foo.java"})," moved to ",(0,n.jsx)(t.code,{children:"com/veracode/bar/Foo.java"}),". Veracode does not explicitly detect source filename changes."]})]}),(0,n.jsxs)(t.tr,{children:[(0,n.jsx)(t.td,{children:"Multiple flaws on the same line"}),(0,n.jsx)(t.td,{children:"Flaw matching has improved to be able to correctly distinguish between flaws in applications that have multiple flaws on the same line. However, some past scans may have occurred when Veracode was not able to tell the difference between these flaws, causing flaws to close and reopen incorrectly. Future scans of these applications may cause some new flaws to appear because Veracode can now distinguish between multiple flaws on the same line."})]})]})]}),"\n",(0,n.jsx)(t.h3,{id:"known-limitations",children:"Known limitations"}),"\n",(0,n.jsx)(t.p,{children:"When the code provided to Veracode from the previous scanned code undergoes changes, flaw matching becomes more challenging, and it introduces the following limitations, which Veracode is actively addressing."}),"\n",(0,n.jsx)(t.h4,{id:"duplications",children:"Duplications"}),"\n",(0,n.jsx)(t.p,{children:"If there are identical copies of a flaw within different source files, you expect to see separate flaws reported. However, Veracode does not recognize this duplication and only reports a single flaw."}),"\n",(0,n.jsx)(t.h4,{id:"third-party-fingerprinting",children:"Third-party fingerprinting"}),"\n",(0,n.jsx)(t.p,{children:"In some cases, when there is a build upon the work of a third party, there might not be any changes to a module. As a result, Veracode copies the results from the original module without recognizing that the module actually contains different information. This issue, known as third-party fingerprinting, occurs because Veracode does not utilize shared dependencies effectively. Therefore, it sometimes reports two separate flaws instead of matching them with existing flaws, even though the underlying vulnerabilities are the same."}),"\n",(0,n.jsx)(t.h2,{id:"dynamic-analysis-flaw-matching",children:"Dynamic Analysis flaw matching"}),"\n",(0,n.jsxs)(t.p,{children:["Dynamic Analysis flaw matching requires you to ",(0,n.jsx)(t.a,{href:"/km-docusaurus-test/r/t_link_apps",children:"link the scan results to an application profile"}),". Each scan identifies flaws in the latest version of the application and Veracode determines their statuses based on whether they were found in the previous scan."]})]})}function d(e={}){const{wrapper:t}={...(0,i.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},11151:(e,t,a)=>{a.d(t,{Z:()=>c,a:()=>o});var n=a(67294);const i={},s=n.createContext(i);function o(e){const t=n.useContext(s);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),n.createElement(s.Provider,{value:t},e.children)}}}]);