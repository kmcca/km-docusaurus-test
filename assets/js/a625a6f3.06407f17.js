"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[70550],{50891:(e,a,n)=>{n.r(a),n.d(a,{assets:()=>r,contentTitle:()=>i,default:()=>p,frontMatter:()=>t,metadata:()=>d,toc:()=>c});var s=n(85893),o=n(11151);const t={title:"Using Lambda layers",slug:"/r/c_lambda_layers"},i=void 0,d={id:"guides/packaging/lambda_layers",title:"Using Lambda layers",description:"By using Lambda layers, you can reduce the packaging size of components that different Lambda functions reuse.",source:"@site/docs/guides/03_packaging/02_lambda_layers.md",sourceDirName:"guides/03_packaging",slug:"/r/c_lambda_layers",permalink:"/km-docusaurus-test/r/c_lambda_layers",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Using Lambda layers",slug:"/r/c_lambda_layers"},sidebar:"tutorialSidebar",previous:{title:"Initial support and supported languages meaning",permalink:"/km-docusaurus-test/r/Initial_Support_and_Supported_Languages_Meaning"},next:{title:"Pipeline Scan supported languages",permalink:"/km-docusaurus-test/r/Pipeline_Scan_Supported_Languages"}},r={},c=[{value:"Uploading Lambda layers as a standard deployment package",id:"uploading-lambda-layers-as-a-standard-deployment-package",level:2},{value:"Uploading Lambda layers as part of a Lambda function deployment package",id:"uploading-lambda-layers-as-part-of-a-lambda-function-deployment-package",level:2}];function l(e){const a={a:"a",admonition:"admonition",code:"code",h2:"h2",li:"li",p:"p",pre:"pre",ul:"ul",...(0,o.a)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(a.p,{children:"By using Lambda layers, you can reduce the packaging size of components that different Lambda functions reuse."}),"\n",(0,s.jsxs)(a.p,{children:["AWS Lambda requirements for Lambda layers control how the AWS Lambda framework accesses the content of the uploaded layers at runtime. For information, see ",(0,s.jsx)(a.a,{href:"https://docs.aws.amazon.com/lambda/",children:"https://docs.aws.amazon.com/lambda/"})," and search for Lambda layers configuration. The Veracode upload process accepts different technologies and packaging techniques during the upload and prescan phases. Veracode evaluates the uploaded artifacts according to their format and content."]}),"\n",(0,s.jsx)(a.p,{children:"Lambda layer packages resemble dependency packages that you upload for other technologies. Veracode cannot uniquely identify a Lambda layer package as a layer for a specific Lambda function or set of functions without additional information for the uploaded packages. The Veracode upload process does not currently support JSON, YML, or YAML files for the identification of layers. However, you can use different packaging strategies to analyze the components included in Lambda layers."}),"\n",(0,s.jsx)(a.h2,{id:"uploading-lambda-layers-as-a-standard-deployment-package",children:"Uploading Lambda layers as a standard deployment package"}),"\n",(0,s.jsx)(a.p,{children:"This sample strategy shows considerations when analyzing applications using Lambda functions and layers. In this example, an application consists of separate archives:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.code,{children:"lambda-function.zip"})}),"\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.code,{children:"layers1.zip"})}),"\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.code,{children:"layers2.zip"})}),"\n"]}),"\n",(0,s.jsxs)(a.p,{children:["These three artifacts upload separately. This upload approach scans the Lambda function as a separate unit. The scan may not report flaws in components contained in ",(0,s.jsx)(a.code,{children:"layers1.zip"})," or ",(0,s.jsx)(a.code,{children:"layers2.zip"})," that have a source in ",(0,s.jsx)(a.code,{children:"lambda-function"}),", because components in ",(0,s.jsx)(a.code,{children:"layers1"})," and ",(0,s.jsx)(a.code,{children:"layers2"})," may be considered third-party components. Depending on the module selection choices you use for the scan, if you select the components in ",(0,s.jsx)(a.code,{children:"layers1"})," and ",(0,s.jsx)(a.code,{children:"layers2"})," for an entry-point scan, you can analyze flaws that originate inside those components."]}),"\n",(0,s.jsx)(a.p,{children:"Uploading Lambda Layers as part of a Lambda function deployment does not affect Veracode Software Composition Analysis. Veracode reports vulnerabilities in components uploaded in layers1 and layers2 as normal."}),"\n",(0,s.jsx)(a.h2,{id:"uploading-lambda-layers-as-part-of-a-lambda-function-deployment-package",children:"Uploading Lambda layers as part of a Lambda function deployment package"}),"\n",(0,s.jsx)(a.p,{children:"This sample strategy shows considerations when analyzing applications using Lambda functions and layers. This approach requires you to package components managed as Lambda layers as if the Lambda function package is self-contained. When you move dependencies outside the function code to be managed as layers, AWS requires you to package them with a defined folder structure that depends on the runtime used by the Lambda function."}),"\n",(0,s.jsx)(a.p,{children:"Include these dependencies as part of the same Lambda package so that they are uploaded as a single unit to scan."}),"\n",(0,s.jsx)(a.p,{children:"In this example, an application is composed of separate archives:"}),"\n",(0,s.jsxs)(a.ul,{children:["\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.code,{children:"lambda-function.zip"})}),"\n",(0,s.jsx)(a.li,{children:(0,s.jsx)(a.code,{children:"layer1.zip"})}),"\n"]}),"\n",(0,s.jsx)(a.p,{children:"With this content:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{children:"   lambda-function.zip\n   \u2514\u2500\u2500 myfunction.js\n\n\n   layer1.zip\n   \u2514\u2500\u2500 nodejs\n   \u2514\u2500\u2500 node_modules\n   \u251c\u2500\u2500 my_dep1.js\n   \u2514\u2500\u2500 my_dep2.js\n\n"})}),"\n",(0,s.jsx)(a.p,{children:"You can upload a package with this structure:"}),"\n",(0,s.jsx)(a.pre,{children:(0,s.jsx)(a.code,{children:"    self-contained-lambda.zip\n    \u251c\u2500\u2500 myfunction.js\n    \u2514\u2500\u2500 nodejs\n    \u2514\u2500\u2500 node_modules\n    \u251c\u2500\u2500 my_deps1.js\n    \u2514\u2500\u2500 my_deps2.js\n\n"})}),"\n",(0,s.jsx)(a.p,{children:"Packaging the components in this way does not affect your Veracode Software Composition Analysis results."}),"\n",(0,s.jsxs)(a.admonition,{type:"note",children:[(0,s.jsx)(a.p,{children:"You cannot include the layer archive into the Lambda function package. You must include dependencies as if they are not part of a layer package. Uploading a package as shown in this example prevents Veracode from analyzing the included dependencies:"}),(0,s.jsx)("code",{children:(0,s.jsxs)(a.p,{children:["invalid-self-contained-lambda.zip",(0,s.jsx)("br",{}),"\n\u251c\u2500\u2500 myfunction.js",(0,s.jsx)("br",{}),"\n\u2514\u2500\u2500 layer1.zip",(0,s.jsx)("br",{})]})})]})]})}function p(e={}){const{wrapper:a}={...(0,o.a)(),...e.components};return a?(0,s.jsx)(a,{...e,children:(0,s.jsx)(l,{...e})}):l(e)}},11151:(e,a,n)=>{n.d(a,{Z:()=>d,a:()=>i});var s=n(67294);const o={},t=s.createContext(o);function i(e){const a=s.useContext(t);return s.useMemo((function(){return"function"==typeof e?e(a):{...a,...e}}),[a,e])}function d(e){let a;return a=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),s.createElement(t.Provider,{value:a},e.children)}}}]);