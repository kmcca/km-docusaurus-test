"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[21548],{26487:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>p,frontMatter:()=>a,metadata:()=>o,toc:()=>l});var i=s(85893),n=s(11151);const a={title:"Prevent stored XSS attacks",slug:"/r/stored-xss"},r=void 0,o={id:"guides/dynamic_analysis/dast_essentials/dast_essentials_xss/stored-xss",title:"Prevent stored XSS attacks",description:"This section discusses stored XSS vulnerabilities and how to prevent them.",source:"@site/docs/guides/08_dynamic_analysis/15_dast_essentials/07_dast_essentials_xss/02_stored-xss.md",sourceDirName:"guides/08_dynamic_analysis/15_dast_essentials/07_dast_essentials_xss",slug:"/r/stored-xss",permalink:"/km-docusaurus-test/r/stored-xss",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Prevent stored XSS attacks",slug:"/r/stored-xss"},sidebar:"tutorialSidebar",previous:{title:"Prevent reflected XSS attacks",permalink:"/km-docusaurus-test/r/reflected-xss"},next:{title:"About cross-site scripting (XSS) attacks",permalink:"/km-docusaurus-test/r/cross-site-scripting"}},c={},l=[{value:"About stored cross-site scripting",id:"about-stored-cross-site-scripting",level:2},{value:"Stored XSS payloads",id:"stored-xss-payloads",level:2},{value:"Polyglot-based XSS payload",id:"polyglot-based-xss-payload",level:3},{value:"JavaScript directive for image XSS payload",id:"javascript-directive-for-image-xss-payload",level:3},{value:"Bypassing HTML entity encoding",id:"bypassing-html-entity-encoding",level:3},{value:"Improper IMG tags",id:"improper-img-tags",level:3},{value:"Attack examples",id:"attack-examples",level:2},{value:"Cookie grabbing",id:"cookie-grabbing",level:3},{value:"Error page manipulation",id:"error-page-manipulation",level:3},{value:"Prevent attacks",id:"prevent-attacks",level:2},{value:"Perform proper input validation",id:"perform-proper-input-validation",level:3},{value:"Use a vulnerability scanner",id:"use-a-vulnerability-scanner",level:3},{value:"Enforce a strong Content Security Policy (CSP)",id:"enforce-a-strong-content-security-policy-csp",level:3},{value:"Escape dynamic content",id:"escape-dynamic-content",level:3}];function d(e){const t={a:"a",code:"code",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",ul:"ul",...(0,n.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"This section discusses stored XSS vulnerabilities and how to prevent them."}),"\n",(0,i.jsx)(t.h2,{id:"about-stored-cross-site-scripting",children:"About stored cross-site scripting"}),"\n",(0,i.jsx)(t.p,{children:"In a stored XSS attack, the vulnerable web application receives user-supplied input from untrusted sources and stores it. This malicious content also gets included in the later HTTP responses sent by the server."}),"\n",(0,i.jsx)(t.p,{children:"To perform a Stored XSS attack, hackers only need to identify a security vulnerability within the backend application that allows executing malicious requests. This makes it more exploitable as hackers do not need to craft external methods for supplying untrusted inputs to the target application server."}),"\n",(0,i.jsx)(t.p,{children:"Stored XSS, also known as Type-1 or Persistent XSS attacks, typically rely on unsanitized user input points for scripts permanently stored on the target servers. Since these attacks allow malicious users to control how the browser executes a script, they can typically facilitate a complete user account takeover."}),"\n",(0,i.jsx)(t.p,{children:"The impact of a successful attack ranges from mild to full-blown compromise depending on the privileges assigned to the valid affected user. Some consequences of successful XSS attacks include:"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://crashtest-security.com/session-hijacking-prevention/",children:"Session hijacking attacks"})}),"\n",(0,i.jsx)(t.li,{children:(0,i.jsx)(t.a,{href:"https://crashtest-security.com/responsible-disclosure/",children:"Disclosure of user files/data"})}),"\n",(0,i.jsx)(t.li,{children:"Installation of malware/Trojan programs"}),"\n",(0,i.jsx)(t.li,{children:"Redirecting users to trustworthy-looking clone login forms for phishing attempts"}),"\n",(0,i.jsx)(t.li,{children:"Web content spoofing"}),"\n"]}),"\n",(0,i.jsx)(t.p,{children:"Stored XSS differs from reflected XSS. In reflected XSS, the server executes the malicious content and includes it only in the immediate HTTP response, whereas, in stored XSS, the arbitrary code gets stored."}),"\n",(0,i.jsx)(t.p,{children:"Unlike other XSS attacks where the user has to be logged in at the time of bad code injection, the stored XSS payload is persisted within the web server and is executed by the browser for every user that signs in, making it the more dangerous type of attack."}),"\n",(0,i.jsx)(t.p,{children:"Hackers have targeted stored XSS vulnerabilities for a long time since the malicious code stored on the target application has an enormous reach."}),"\n",(0,i.jsx)(t.h2,{id:"stored-xss-payloads",children:"Stored XSS payloads"}),"\n",(0,i.jsx)(t.p,{children:"A persistent attack aims to inject bad code into popular user-supplied input points, such as comments on blog posts, username fields, and message boards. The payload lets the malicious user bypass XSS filters and input validation checks."}),"\n",(0,i.jsx)(t.p,{children:"Knowledge of these payloads is essential for application security professionals looking to test and mitigate the stored XSS vulnerability. Some of these payloads include:"}),"\n",(0,i.jsx)(t.h3,{id:"polyglot-based-xss-payload",children:"Polyglot-based XSS payload"}),"\n",(0,i.jsx)(t.p,{children:"This type of attack targets a vulnerability in polyglot- a framework that enables the execution of code in multiple contexts in raw form. This creates an XSS injection attack vector since attackers can use polyglot scripts to bypass Content Security Policies (CSPs). A typical polyglot XSS script would look similar to:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"javascript:/*--\x3e</title></style></textarea><\/script></xmp><svg/onload='+/\"/+/onmouseover=1/+/[*/[]/+alert(1)//'>\n"})}),"\n",(0,i.jsx)(t.h3,{id:"javascript-directive-for-image-xss-payload",children:"JavaScript directive for image XSS payload"}),"\n",(0,i.jsx)(t.p,{children:"This payload allows for the execution of JavaScript within the context of an image. Attackers mainly use this strategy to perform malicious activities on user profile pages and other image links. The script would look like this:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"<IMG SRC=\"javascript:alert('XSS');\">\n"})}),"\n",(0,i.jsx)(t.h3,{id:"bypassing-html-entity-encoding",children:"Bypassing HTML entity encoding"}),"\n",(0,i.jsx)(t.p,{children:"HTML entity encoding forms a typical first line of defense against cross-site scripting vulnerabilities by performing input data validation. Bad actors often craft scripts to bypass or disable HTML encoding, allowing them to supply unvalidated input to the server. The HTML entity bypass code would look similar to:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"<IMG SRC=javascript:alert(&quot;XSS&quot;)>\n"})}),"\n",(0,i.jsx)(t.h3,{id:"improper-img-tags",children:"Improper IMG tags"}),"\n",(0,i.jsxs)(t.p,{children:["This attack payload relies on compromised browser rendering to create an attack surface in an ",(0,i.jsx)(t.code,{children:"<IMG>"})," tag. This allows them to insert a JavaScript event method into objects created within image tags. The code segment below shows a malformed IMG tag used to test for and exploit stored XSS vulnerabilities. The script would look similar to:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'<IMG """><SCRIPT>alert("XSS")<\/SCRIPT>"\\>\n'})}),"\n",(0,i.jsx)(t.h2,{id:"attack-examples",children:"Attack examples"}),"\n",(0,i.jsx)(t.p,{children:"Ways to exploit stored cross-site scripting vulnerabilities include:"}),"\n",(0,i.jsx)(t.h3,{id:"cookie-grabbing",children:"Cookie grabbing"}),"\n",(0,i.jsx)(t.p,{children:"Attackers can steal a session cookie from logged-in, authenticated users. They inject client-side scripts that pass an escaped content of the authentication cookie details for the document. To do this, they only have to include the below code in any form which accepts user input, such as user profiles, private messages, or user forums:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"<SCRIPT type=\"text/javascript\">  \nvar adr = '../evil.php?cakemonster=' + escape(document.cookie);  \n<\/SCRIPT>\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This script execution writes the cookie details to the ",(0,i.jsx)(t.code,{children:"evil.php"})," file, where attackers can check the result of the script to assume the identity of the user."]}),"\n",(0,i.jsx)(t.h3,{id:"error-page-manipulation",children:"Error page manipulation"}),"\n",(0,i.jsx)(t.p,{children:"Attackers can also target error messages like the classic 404 error page, which notifies users of non-existing pages to inject XSS code. Assuming the site that informs the user about the missing page runs on code similar to:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:'<html>  \n  <body>  \n   <? php  \n    print "Not found:". urldecode($_SERVER["REQUEST_URI"]);  \n   ?>  \n  </body>  \n</html>\n'})}),"\n",(0,i.jsxs)(t.p,{children:["For example, if a user selects a non-existent webpage located at ",(0,i.jsx)(t.code,{children:"http://darwin.test/non_existent_file"}),", they get the following response:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{children:"Not found: /non_existent_file\n"})}),"\n",(0,i.jsxs)(t.p,{children:["Attackers can manipulate this error page to include a bad code: ",(0,i.jsx)(t.code,{children:'http://darwin.test/<script>alert("TEST");<\/script>'}),", the HTTP response now is an error page, but it would also include the bad JavaScript code ",(0,i.jsx)(t.code,{children:'<script>alert("TEST");<\/script>'})]}),"\n",(0,i.jsx)(t.p,{children:"Once the script tags are successfully injected, users can be misled into selecting the malicious link in a phishing email or social engineering tricks."}),"\n",(0,i.jsx)(t.h2,{id:"prevent-attacks",children:"Prevent attacks"}),"\n",(0,i.jsx)(t.p,{children:"Below are the ways to prevent hackers from exploiting the stored XSS vulnerability in a web application:"}),"\n",(0,i.jsx)(t.h3,{id:"perform-proper-input-validation",children:"Perform proper input validation"}),"\n",(0,i.jsxs)(t.p,{children:["Input validation is the default primary step to prevent ",(0,i.jsx)(t.a,{href:"https://crashtest-security.com/different-injection-attack-types/",children:"injection attacks"}),". Proper input validation controls must be performed at every application tier to ensure it only accepts trusted user input. Encoding input before sending it to the browser ensures that attackers cannot tamper with user-supplied data."]}),"\n",(0,i.jsx)(t.p,{children:"Web developers should als enforce integrity checks throughout the software lifecycle to ensure the target application does not include dangerous content in its response."}),"\n",(0,i.jsx)(t.p,{children:"These should include content filtering checks to ensure that input from users does not abuse the business rules to ensure data parameters stay within allowed ranges."}),"\n",(0,i.jsx)(t.h3,{id:"use-a-vulnerability-scanner",children:"Use a vulnerability scanner"}),"\n",(0,i.jsx)(t.p,{children:"It is difficult to test for stored XSS vulnerabilities manually. However, an automated vulnerability scanner can test for all data entry and exit points used to inject and execute malicious scripts."}),"\n",(0,i.jsx)(t.p,{children:"DAST Essentials ships with a vulnerability scanner that helps prevent XSS attacks by mapping the relationships between entries and response exit points to ensure that only valid scripts are accepted by the server and executed in the browser. DAST Essentials also includes an automated penetration testing solution to fix stored XSS vulnerabilities before being shipped into production."}),"\n",(0,i.jsx)(t.h3,{id:"enforce-a-strong-content-security-policy-csp",children:"Enforce a strong Content Security Policy (CSP)"}),"\n",(0,i.jsxs)(t.p,{children:["All modern browsers support CSPs, which developers use to instruct browsers on the allowed sources to load JavaScript and other resources. Since stored XSS attacks rely on the attacker to include malicious inline ",(0,i.jsx)(t.code,{children:"<script>"})," tags within the ",(0,i.jsx)(t.code,{children:"<html>"})," tag of the page, CSPs prevent attacks by implementing the same-origin policy. The content security policy is set as a ",(0,i.jsx)(t.code,{children:"<meta>"})," tag within the ",(0,i.jsx)(t.code,{children:"<head>"})," tag of the page."]}),"\n",(0,i.jsx)(t.h3,{id:"escape-dynamic-content",children:"Escape dynamic content"}),"\n",(0,i.jsx)(t.p,{children:"Stored XSS attacks take advantage of flaws in the delivery of dynamic content persisted within the application backend. First, it is essential to keep registered users from submitting raw HTML in input forms. Additionally, any dynamic content and special characters should be escaped so that the browser does not treat them as raw HTML source code but as the contents of HTML tags."})]})}function p(e={}){const{wrapper:t}={...(0,n.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,t,s)=>{s.d(t,{Z:()=>o,a:()=>r});var i=s(67294);const n={},a=i.createContext(n);function r(e){const t=i.useContext(a);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(n):e.components||n:r(e.components),i.createElement(a.Provider,{value:t},e.children)}}}]);