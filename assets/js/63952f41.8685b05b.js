"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[72915],{14950:(e,t,s)=>{s.r(t),s.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>o,toc:()=>h});var n=s(85893),a=s(11151);const i={title:"Enable TLS_FALLBACK_SCSV",slug:"/r/enable-tls_fallback_scsv"},r=void 0,o={id:"guides/dynamic_analysis/dast_essentials/dast_essentials_tls_vulns/enable-tls_fallback_scsv",title:"Enable TLS_FALLBACK_SCSV",description:"The TLS Signaling Cipher Suite Value (SCSV) is protection against TLS/SSL downgrade attacks. If enabled, the server ensures that the most robust protocol that both client and server understand is used.",source:"@site/docs/guides/08_dynamic_analysis/15_dast_essentials/08_dast_essentials_tls_vulns/29_enable-tls_fallback_scsv.md",sourceDirName:"guides/08_dynamic_analysis/15_dast_essentials/08_dast_essentials_tls_vulns",slug:"/r/enable-tls_fallback_scsv",permalink:"/km-docusaurus-test/r/enable-tls_fallback_scsv",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:29,frontMatter:{title:"Enable TLS_FALLBACK_SCSV",slug:"/r/enable-tls_fallback_scsv"},sidebar:"tutorialSidebar",previous:{title:"Prevent SSL BEAST attacks",permalink:"/km-docusaurus-test/r/prevent-ssl-beast"},next:{title:"Prevent SSL renegotiation attacks",permalink:"/km-docusaurus-test/r/secure-ssl-renegotiation"}},l={},h=[{value:"Security assessment",id:"security-assessment",level:2},{value:"Vulnerability information",id:"vulnerability-information",level:2},{value:"Enable TLS_FALLBACK_SCSV",id:"enable-tls_fallback_scsv",level:3}];function c(e){const t={a:"a",br:"br",code:"code",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.p,{children:"The TLS Signaling Cipher Suite Value (SCSV) is protection against TLS/SSL downgrade attacks. If enabled, the server ensures that the most robust protocol that both client and server understand is used."}),"\n",(0,n.jsx)(t.h2,{id:"security-assessment",children:"Security assessment"}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.img,{alt:"Security_Assessment_ EnableTLS_FALLBACK_SCSV",src:s(2911).Z+"",width:"907",height:"332"})}),"\n",(0,n.jsxs)(t.p,{children:["CVSS vector:  ",(0,n.jsxs)(t.a,{href:"https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:L/A:N",children:["AV",":N","/AC",":L","/PR",":N","/UI",":N","/S",":U","/C",":L","/I",":L","/A",":N"]})]}),"\n",(0,n.jsx)(t.h2,{id:"vulnerability-information",children:"Vulnerability information"}),"\n",(0,n.jsx)(t.p,{children:"To avoid the issue of clients downgrading, you can use the TLS_FALLBACK_SCSV signal as a workaround. This workaround serves as a dummy fake cipher suite listed during the Client Hello message to the server. It is a mechanism to avoid a server crash due to an unsuccessful handshake and protocol version negotiation."}),"\n",(0,n.jsx)(t.p,{children:"Essentially, the signal lets the server know that the client supports a higher version than the one it is currently advertising and that a previous attempt at a connection failed for some reason. In this way, the server is informed of a better version being available and does not crash due to this information."}),"\n",(0,n.jsx)(t.p,{children:"Furthermore, by being notified that the client supports a higher version, the server will issue an inappropriate_fallback alert and abort the connection attempt to reattempt to establish a more secure connection."}),"\n",(0,n.jsx)(t.p,{children:"But what if there is a man-in-the-middle actively interfering with client connection attempts? As long as TLS_FALLBACK_SCSV is supported both on the client and the server side, this will prevent the attacker from downgrading to insecure protocols since the server will know that a different version can be used and will not establish another one. As such, this signal serves to protect against any downgrade attempt."}),"\n",(0,n.jsx)(t.p,{children:"What is important to note is that to work, TLS_FALLBACK_SCSV must be enabled on both the client and server sides. So if the client supports it, but the server does not, the latter will disregard the signal and attempt the connection."}),"\n",(0,n.jsx)(t.h3,{id:"enable-tls_fallback_scsv",children:"Enable TLS_FALLBACK_SCSV"}),"\n",(0,n.jsx)(t.p,{children:"When OpenSSL is used as a base for the SSL/TLS encryption (e.g., for an Apache or Nginx webserver), update it to the latest version. For example, the following versions are known to support TLS_FALLBACK_SCSV:"}),"\n",(0,n.jsxs)(t.ul,{children:["\n",(0,n.jsx)(t.li,{children:"OpenSSL 1.0.1j"}),"\n",(0,n.jsx)(t.li,{children:"OpenSSL 1.0.0o"}),"\n",(0,n.jsx)(t.li,{children:"OpenSSL 0.9.8zc"}),"\n"]}),"\n",(0,n.jsx)(t.p,{children:"E.g., run:"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{children:"apt-get update; apt-get upgrade # Debian / Ubuntu  \nyum update                      # RHeL / CentOS  \npacman -Syu                     # Arch Linux\n"})}),"\n",(0,n.jsx)(t.p,{children:(0,n.jsx)(t.strong,{children:"Assumptions and effects:"})}),"\n",(0,n.jsxs)(t.p,{children:["The draft RFC states that the server MUST refuse the connection if the maximum protocol version the server supports is higher than the one advertised within the Client Hello with the TLS_FALLBACK_SCSV signal. This assumes that the server supports all protocol versions between the Client stated version and the server maximum. What can the server infer about the Client? The Client supports at least one protocol version higher than that within the Client Hello. But that is all the server knows. So what if one of those intermediate versions is not supported by the server and happens to be the highest version the Client supports?",(0,n.jsx)(t.br,{}),"\n","In previous pentests, servers did not support TLS v1.1 but supported TLS v1.0 and TLS v1.2. Imagine a client that supports TLSv1.1 at best, so it starts with a TLSv1.1 connection. TLS allows the server to respond, saying effectively, sorry, can't do that, I can do TLSv1.0\xb3. But suppose it is one of those buggy servers for which the downgrade fallback was intended. In this case, the connection fails unexpectedly, and therefore the browser attempts the link again, using TLS v1.0 with the TLS_FALLBACK_SCSV signal. The server then refuses the relationship as its full TLS version is 1.2 and assumes the Client can do better. But the Client does not understand 1.2, and the server does not want to speak 1.1. the two will never discuss it with one another."]})]})}function d(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(c,{...e})}):c(e)}},2911:(e,t,s)=>{s.d(t,{Z:()=>n});const n=s.p+"assets/images/Security_Assessment_ EnableTLS_FALLBACK_SCSV-e655b54f2701dcf62dfffcaf808f65d9.png"},11151:(e,t,s)=>{s.d(t,{Z:()=>o,a:()=>r});var n=s(67294);const a={},i=n.createContext(a);function r(e){const t=n.useContext(i);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),n.createElement(i.Provider,{value:t},e.children)}}}]);