"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[73697],{49297:(e,s,t)=>{t.r(s),t.d(s,{assets:()=>c,contentTitle:()=>r,default:()=>d,frontMatter:()=>o,metadata:()=>a,toc:()=>l});var n=t(85893),i=t(11151);const o={title:"Harden TLS session resumption",slug:"/r/harden-tls-session-resumption"},r=void 0,a={id:"guides/dynamic_analysis/dast_essentials/dast_essentials_tls_vulns/harden-tls-session-resumption",title:"Harden TLS session resumption",description:"The TLS session resumption functionality is misconfigured. This opens attackers the possibility to steal existing TLS sessions from other users. This section contains guidelines and code snippets for Apache and Nginx on fixing TLS Session Resumption security vulnerabilities.",source:"@site/docs/guides/08_dynamic_analysis/15_dast_essentials/08_dast_essentials_tls_vulns/01_harden-tls-session-resumption.md",sourceDirName:"guides/08_dynamic_analysis/15_dast_essentials/08_dast_essentials_tls_vulns",slug:"/r/harden-tls-session-resumption",permalink:"/km-docusaurus-test/r/harden-tls-session-resumption",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Harden TLS session resumption",slug:"/r/harden-tls-session-resumption"},sidebar:"tutorialSidebar",previous:{title:"About Content Security Policy",permalink:"/km-docusaurus-test/r/content-security-policy"},next:{title:"Certificate revocation",permalink:"/km-docusaurus-test/r/certificate-revocation"}},c={},l=[{value:"Security assessment",id:"security-assessment",level:2},{value:"Vulnerability information",id:"vulnerability-information",level:2},{value:"Prevent attacks",id:"prevent-attacks",level:2},{value:"Apache",id:"apache",level:3},{value:"Nginx",id:"nginx",level:3}];function h(e){const s={a:"a",code:"code",h2:"h2",h3:"h3",img:"img",p:"p",pre:"pre",...(0,i.a)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(s.p,{children:"The TLS session resumption functionality is misconfigured. This opens attackers the possibility to steal existing TLS sessions from other users. This section contains guidelines and code snippets for Apache and Nginx on fixing TLS Session Resumption security vulnerabilities."}),"\n",(0,n.jsx)(s.h2,{id:"security-assessment",children:"Security assessment"}),"\n",(0,n.jsx)(s.p,{children:(0,n.jsx)(s.img,{alt:"Security_Assessment_HardenTLSSessionResumption",src:t(34033).Z+"",width:"907",height:"332"})}),"\n",(0,n.jsxs)(s.p,{children:["CVSS vector:  ",(0,n.jsxs)(s.a,{href:"https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator?vector=AV:N/AC:H/PR:N/UI:N/S:U/C:L/I:L/A:N",children:["AV",":N","/AC",":H","/PR",":N","/UI",":N","/S",":U","/C",":L","/I",":L","/A",":N"]})]}),"\n",(0,n.jsx)(s.h2,{id:"vulnerability-information",children:"Vulnerability information"}),"\n",(0,n.jsx)(s.p,{children:"The TLS session resumption functionality is misconfigured. This opens attackers the possibility to steal existing TLS sessions from other users."}),"\n",(0,n.jsx)(s.p,{children:"Generally, the TLS session resumption functionality speeds up client reconnections, as no full TLS handshake needs to occur. Instead, a value known from a previous session is used to verify the authenticity of the connection. However, if the server does not rotate or renew its secrets properly, the session resumption breaks perfect forward secrecy."}),"\n",(0,n.jsx)(s.h2,{id:"prevent-attacks",children:"Prevent attacks"}),"\n",(0,n.jsx)(s.p,{children:"To disable TLS session resumption, complete the following configurations. Further possibilities exist to harden the session resumption feature but are based on scheduled restarts of the webserver."}),"\n",(0,n.jsx)(s.h3,{id:"apache",children:"Apache"}),"\n",(0,n.jsxs)(s.p,{children:["On Apache you need insert the ",(0,n.jsx)(s.code,{children:"SSLOpenSSLConfCmd"})," directive into the virtual host configuration in ",(0,n.jsx)(s.code,{children:"/etc/apache2/sites-enabled/domain.confor/etc/httpd/sites-enabled/domain.conf"}),":"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"<IfModule mod_ssl.c>  \n    SSLStaplingCache shmcb:/tmp/stapling_cache(128000)  \n    <VirtualHost *:443>  \n   \n            ServerAdmin webmaster@localhost  \n            ServerName example.com   \n            DocumentRoot /var/www  \n      \n            SSLEngine on  \n  \n            SSLCertificateFile /etc/ssl/new.pem  \n            SSLCertificateKeyFile /etc/ssl/privkey.key  \n  \n  \n            SSLOpenSSLConfCmd Options -SessionTicket  \n    </VirtualHost>  \n</IfModule>\n"})}),"\n",(0,n.jsx)(s.h3,{id:"nginx",children:"Nginx"}),"\n",(0,n.jsxs)(s.p,{children:["For Nginx, update the configuration file which is usually located at ",(0,n.jsx)(s.code,{children:"/etc/nginx/nginx.conf"}),", ",(0,n.jsx)(s.code,{children:"/etc/nginx/sited-enabled/yoursite.com"})," (Ubuntu/Debian) or ",(0,n.jsx)(s.code,{children:"/etc/nginx/conf.d/nginx.conf"})," (RHEL/CentOS). Add the ",(0,n.jsx)(s.code,{children:"ssl_session_tickets"})," directive to the ",(0,n.jsx)(s.code,{children:"server"})," section:"]}),"\n",(0,n.jsx)(s.pre,{children:(0,n.jsx)(s.code,{children:"server {  \n         listen   443;  \n         server_name example.org;  \n  \n         root /usr/share/nginx/www;  \n         index index.html index.htm;  \n  \n         ssl on;  \n         ssl_certificate /etc/ssl/new;  \n         ssl_certificate_key /etc/ssl/privkey.key;  \n  \n  \n         ssl_session_tickets off;  \n}\n"})}),"\n",(0,n.jsx)(s.p,{children:"DAST Essentials uses an in-memory key generator daemon that generates a new, timestamped key every hour to meet these security goals. Keys are encrypted so that only the nginx servers can decrypt them. Then, with the CloudFlare secure data propagation infrastructure, ticket keys replicate from one master instance to any or all of the PoPs worldwide. Each host periodically queries the local copy of the database through a Memcached interface for fresh encryption keys for this hour. To summarize, the key generation daemon generates keys randomly. It rotates them hourly, and keys are securely distributed to any or all hosts worldwide without being written to disk."}),"\n",(0,n.jsx)(s.p,{children:"There are some technical details still worth mentioning. First, configure distributed clock synchronization. As an example, there may well be one host who thinks it is UTC 12:01 pm while other hosts still think it is UTC 11:59 am. The faster-clock host might start encrypting session tickets with the key of 12:00 pm, while other hosts couldn't decrypt those tickets because they don't know the new key yet. Or the fast-clock host might find the key is not yet available due to propagation delay. Instead of dedicating efforts to synchronization, we solve the problem by breaking the synchronization requirement. The key daemon generates keys one hour ahead, and each host would opportunistically save the key for the next hour (if there's any) as a decryption-only key. Even with one or more faster-clock hosts, session resumption by ticket still works without interruption because they will still decrypt session tickets encrypted by the other."}),"\n",(0,n.jsx)(s.p,{children:"Also, the session ticket lifetime hint is set to 18 hours, the same value for SSL session timeout. This is because each server keeps ticket keys for ticket decryption for the past 18 hours."})]})}function d(e={}){const{wrapper:s}={...(0,i.a)(),...e.components};return s?(0,n.jsx)(s,{...e,children:(0,n.jsx)(h,{...e})}):h(e)}},34033:(e,s,t)=>{t.d(s,{Z:()=>n});const n=t.p+"assets/images/Security_Assessment_IncreaseTLSKeySize-e8b60f72154550155e179584ceb5f1ee.png"},11151:(e,s,t)=>{t.d(s,{Z:()=>a,a:()=>r});var n=t(67294);const i={},o=n.createContext(i);function r(e){const s=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function a(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:r(e.components),n.createElement(o.Provider,{value:s},e.children)}}}]);